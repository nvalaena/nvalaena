/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nvalaena <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2019/11/14 20:33:40 by nvalaena          #+#    #+#             */
/*   Updated: 2019/11/14 20:41:19 by nvalaena         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "get_next_line.h"

int				ft_failed(char **buffer, char **stock)
// функция проверки ошибки
{
	ft_strdel(buffer);
	// удаление части строки двумерного массива буфферной памяти
	ft_strdel(stock);
	// удаление части строки двумерного массива стока
	return (-1);
	// При успешном вызове как open(), так и creat() возвращаемым значением является
    // дескриптор файла. При ошибке оба этих вызова возвращают –1 и устанавливают
    // errno в нужное значение ошибки.
}

int				ft_eof(char **line, char **stock, char **buffer)
// функция считывания количества символов
{
	if (ft_strlen(*stock))
	//если количество символов в stock не равно '\0'
	{
	    // Функция strdup() путем обращения к функции malloc() выделяет память,
	    // достаточную для хранения дубликата строки, на которую указывает str,
	    // а затем производит копирование этой строки в выделенную область и возвращает указатель на нее.
		if (!(*line = ft_strdup(*stock)))
		    // если указатель на строку не создает дубликат строки
		    // в выделенной области и не возвращает указатель на нее
			return (ft_failed(buffer, stock));
		// возращаем функцию ошибки
		ft_strdel(stock);
		// удаление части строки двумерного массива стока
		ft_strdel(buffer);
        // удаление части строки двумерного массива буфферной памяти
		return (1);
		// возвращаем 1
	}
	return (0);
	// в результате функция возвращает 0
}

unsigned int	ft_strchrpos(char *stock, char c)
// функция поиска номера позиции в строке
{
	unsigned int	i;
	// объявление счетчика

	i = 0;
	// начальное значение счетчика
	if (!stock)
	    // если нет массива stock
		return (0);
	// возвращаем 0
	while (stock[i])
	// считываем все элементы строки
	{
		if (stock[i] == c)
		    // если i-ый элемент массива равен символу c
			return (i);
		// возвращаем номер элемента с
		i++;
		// цикл двигается
	}
	return (0);
}

int				ft_realloc_stk(char *tmp, char **stk, char **buffer)
{
	ft_strdel(stk);
	// удаление строки  stk
	if (!(*stk = ft_strdup(tmp)))
        // если указатель на строку не создает дубликат строки
        // в выделенной области и не возвращает указатель на нее
		return (ft_failed(buffer, stk));
	// возвращаем функцию ошибки
	ft_strdel(&tmp);
	// удаляем строку с указателем tmp
	return (1);
	// возвращает 1
}

int				get_next_line(const int fd, char **line)
// основная функция
{
	static char	*stk = NULL;
	// статический массив с размерностью NULL
	char		*buffer;
	// массив buffer
	int			ret;
	//
	char		*tmp;
	// массив tmp

	if (fd < 0 || !line || BUFF_SIZE < 1 || BUFF_SIZE > 10000000)
	    // если файлов меньше 0 или размер буффера меньше 1 или размер буффера больше 1000000
		return (-1);
	// возвращаем -1 , а errno присваивается нужное значение
	stk = (!stk) ? ft_strnew(BUFF_SIZE) : stk;
	// заполняем статический массив, Тернарная условная операция
	// используется в выражениях для получения одного из двух вариантов в зависимости от условия.
	// Поэтому операнд (!stk) должен быть числом (целым или вещественным) или указателем.
	// Сначала вычисляется именно его значение. Оно сравнивается с нулём и, если оно не равно нулю,
	// вычисляется и возвращается ft_strnew(BUFF_SIZE), в случае равенства — stk.
	// Операнды ft_strnew(BUFF_SIZE) и stk могут быть различных, вообще говоря,
	// несовпадающих типов, включая void.
	// ft_strnew(BUFF_SIZE) - создает в динамической памяти строку размером BUFF_SIZE
	while (!(ft_strchr(stk, '\n')))
	// Функция strchr выполняет поиск первого вхождения символа '\n' в строку stk.
	{
		buffer = ft_strnew(BUFF_SIZE);
		// ft_strnew(BUFF_SIZE) - создает в динамической памяти строку размером BUFF_SIZE
		if (!(ret = read(fd, buffer, BUFF_SIZE)))
		    // обработать все ошибки и действительно прочитать все байты до достижения BUFF_SIZE
			return (ft_eof(line, &stk, &buffer));
		// возвращаем команду о том что файл закончен
		if (ret == -1 || !stk || !(tmp = ft_strjoin(stk, buffer)) ||
				ft_realloc_stk(tmp, &stk, &buffer) == -1)
		    // цкил на обработку ошибок
			return (ft_failed(&buffer, &stk));
		ft_strdel(&buffer);
		// удаляем строку с указателем на буффер
	}
	if (!(*line = ft_strsub(stk, 0, ft_strchrpos(stk, '\n'))))
	    // Substr возвращает часть строки stk , специфицированную параметрами 0 и до нужной позиции,
	    // соответственно если не возвращает
		return (ft_failed(&buffer, &stk));
	// обработка ошибки
	if (!(tmp = ft_strsub(stk, ft_strchrpos(stk, '\n') + 1, ft_strlen(stk))) ||
			ft_realloc_stk(tmp, &stk, &buffer) == -1)
	    // 
		return (ft_failed(&buffer, &stk));
	return (1);
}
